import sys
import os 
import argparse
import random
import string
import struct #https://docs.python.it/html/lib/module-struct.html
import math

#logging
def printinfo(msg):
    print("\033[1m\33[33m[!] "+msg+"\033[0m")

def printsuccess(msg):
    print("\033[1m\33[34m[+] "+msg+"\033[0m")

def printfailure(msg):
    print("\033[1m\33[31m[-] "+msg+"\033[0m")

#Parsing the command line arguments
parser=argparse.ArgumentParser(description="Inject new Section to a pre-existing binary",epilog="CODED BY rosemgo&marcobelf")
parser.add_argument("-t","--target",help="Path of the target executable to inject the code into.",required=True)
parser.add_argument("-p","--payload",help="path of the payload to inject into the pe file",required=True)
parser.add_argument("-n","--name",help="Name of the section to inject into executable\nUses a randomly generated name if not provided any.")
parser.add_argument("-d","--dump_on_exec",help="dump the payload on execute",action="store_true")
parser.add_argument("-r","--replace",help="repalace the original file with the injected file",action="store_true")
args=parser.parse_args()

#filtering e tuning gli argomenti passati dalla linea di comando
if (not args.name): #se non viene passato il nome della sezione da creare, viene generato in maniera randomica
    args.name= "".join(random.choices(string.digits+string.ascii_letters,k=4+random.randint(0,4)))
elif(len(args.name)>8):
    args.name=args.name[:8]

#reading the target binary to read for different parameters out of it
#rb consente di aprire un file binario
with open(args.target,"rb") as target: 
    targetData=target.read() # legge tutte le righe
    #print(targetData)

#funzioni di supporto per il processo di iniezione
#il carattere < indica ordinamento dei byte little-endian "i processori Intel e DEC sono little-endian"
#legge una word, ossia 2 byte
def readWORD(offset):
    return struct.unpack("<H", targetData[offset:offset+2])[0]

#legge una double word, ossia 4 byte
def readDWORD(offset):
    return struct.unpack("<L", targetData[offset:offset+4])[0]
    
#legge n doublewords
def readDWORDs(offset,n):
    return struct.unpack("<"+"L"*n, targetData[offset:offset+4*n])

#scrive una doubleword
def writeDWORD(offset, data):
    global targetData
    dat=struct.pack("<L",data)
    #inserisco i data nella posizione offset di targetData, poi targetData continua ad essere uguare da offset+4byte in poi
    targetData = targetData[:offset]+ dat + targetData[offset+4:]

#scrive i dati passati come parametro in una posizione precisa del file target, indicata da offset
#N.B. RICORDARSI DI PASSARE UN PARAMETRO data GI√† CONVERTITO IN BYTE
def writeDATA(offset, data):
    global targetData
    l=len(data)
    #inserisco i dati nella posizione dopo offset
    targetData=targetData[:offset] + data + targetData[offset+l:] #l indica la lunghezza dei dati

#legge un byte all'offset passato come parametro
def readBYTE(offset):
    return struct.unpack("<B", targetData[offset:offset+1])[0]

#legge n bytes
def readBYTES(offset,n):
    return list(struct.unpack("<"+"B"*n, targetData[offset:offset+n]))

#legge n stringhe
def readNString(offset,n):
    txt=""
    for x in range(n):
        char=struct.unpack("<B", targetData[offset+x:offset+x+1])[0]
        if char in map(ord,string.printable) and char!=0:
            txt+=chr(char)
        else:
            break
    return txt


#leggo MZ signature all'inizio del file binario
mzsignature = readWORD(0x00) 

#STRUTTURA DI UN FILE .exe
#typedef struct _IMAGE_DOS_HEADER {
#  WORD e_magic;
#  WORD e_cblp;
#  WORD e_cp;
#  WORD e_crlc;
#  WORD e_cparhdr;
#  WORD e_minalloc;
#  WORD e_maxalloc;
#  WORD e_ss;
#  WORD e_sp;
#  WORD e_csum;
#  WORD e_ip;
#  WORD e_cs;
#  WORD e_lfarlc;
#  WORD e_ovno;
#  WORD e_res[4];
#  WORD e_oemid;
#  WORD e_oeminfo;
#  WORD e_res2[10];
#  LONG e_lfanew; #N.B. INDICA L'OFFSET IN CUI INIZIA _IMAGE_NT_HEADERS
#} IMAGE_DOS_HEADER,*PIMAGE_DOS_HEADER;


#typedef struct _IMAGE_NT_HEADERS {
#  DWORD                 Signature; #4 byte
#  IMAGE_FILE_HEADER     FileHeader;
#  IMAGE_OPTIONAL_HEADER OptionalHeader;
#} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;


#_IMAGE_FILE_HEADER HA UNA DIMENSIONE DI 20 BYTE
#typedef struct _IMAGE_FILE_HEADER{
#  WORD  Machine;
#  WORD  NumberOfSections; 
#  DWORD TimeDateStamp;
#  DWORD PointerToSymbolTable;
#  DWORD NumberOfSymbols;
#  WORD  SizeOfOptionalHeader;
#  WORD  Characteristics;
#} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;


#per arrivare a _IMAGE_OPTIONAL_HEADER si somma 4 byte (dimensione di Signature in _IMAGE_NT_HEADERS) + 20 byte (dimensione di IMAGE_FILE_HEADER) al PE_HEADER_offset #(e_lfanew)
#typedef struct _IMAGE_OPTIONAL_HEADER {
#  WORD                 Magic;
#  BYTE                 MajorLinkerVersion;
#  BYTE                 MinorLinkerVersion;
#  DWORD                SizeOfCode;
#  DWORD                SizeOfInitializedData;
#  DWORD                SizeOfUninitializedData;
#  DWORD                AddressOfEntryPoint;
#  DWORD                BaseOfCode;
#  DWORD                BaseOfData;
#  DWORD                ImageBase;     #offset L'imagebase √® l'indirizzo a cui caricare l'immagine in memoria. Nel caso degli EXE 0x00400000.‚Äã
#  DWORD                SectionAlignment;
#  DWORD                FileAlignment;
#  WORD                 MajorOperatingSystemVersion;
#  WORD                 MinorOperatingSystemVersion;
#  WORD                 MajorImageVersion;
#  WORD                 MinorImageVersion;
#  WORD                 MajorSubsystemVersion;
#  WORD                 MinorSubsystemVersion;
#  DWORD                Win32VersionValue;
#  DWORD                SizeOfImage;
#  DWORD                SizeOfHeaders;
#  DWORD                CheckSum;
#  WORD                 Subsystem;
#  WORD                 DllCharacteristics;
#  DWORD                SizeOfStackReserve;
#  DWORD                SizeOfStackCommit;
#  DWORD                SizeOfHeapReserve;
#  DWORD                SizeOfHeapCommit;
#  DWORD                LoaderFlags;
#  DWORD                NumberOfRvaAndSizes;
#  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; #EXPORTTABLE[0] IMPORTTABLE[1]
#} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;

#SUBITO DOPO _IMAGE_NT_HEADERS CHE COMPRENDE SIA _IMAGE_FILE_HEADER CHE _IMAGE_OPTIONAL_HEADER viene UN ARRAY DI IMAGE_SECTION_HEADER 
#N.B. OGNI SEZIONE HA LA PROPRIA IMAGE_SECTION_HEADER

#typedef struct _IMAGE_SECTION_HEADER { 
#  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];
#  union {
#    DWORD PhysicalAddress;
#    DWORD VirtualSize;
#  } Misc;
#  DWORD VirtualAddress; #E' l'indirizzo del primo byte della specifica sezione quando l'immagine viene caricata in memoria, relativo all'ImageBase‚Äã
#  DWORD SizeOfRawData; #Dimensione dei dati inizializzati. All the raw data in a section must be loaded contiguously. Il valore deve essere un multiplo di FileAlignment (della struct IMAGE_OPTIONAL_HEADER). Se il valore #√® inferiore a VirtualSize la parte il resto viene riempito con 0.‚Äã
#  DWORD PointerToRawData;
#  DWORD PointerToRelocations;
#  DWORD PointerToLinenumbers;
#  WORD  NumberOfRelocations;
#  WORD  NumberOfLinenumbers;
#  DWORD Characteristics;
#} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#N.B.
#IL VIRTUAL ADDRESS E' SEMPRE UN RVA, POI SARA' WINDOWS A CREARE uno spazio VA distinto per ogni processo, indipendente dalla memoria fisica.


#l'offset di IMAGE_NT_HEADERS si trova incrociando la riga 0x30 con la colonna 0C presenti in DOS Header, questo valore indica dove ha inizio la struttura IMAGE_NT_HEADERS, che comprende il campo PE Header
PE_HEADER_offset=readDWORD(0x3c)   #l'offset del PE HEADER dall'inizio del file
print("offset dove si trova la sezione ")
print(PE_HEADER_offset)

#la signature √® data dai primi 2 byte della sezione IMAGE_NT_HEADERS
pesignature = readDWORD(PE_HEADER_offset+0x00) #The PE signature 
print("signature: ")
print(pesignature)

#un primo controllo per sapere se il file selezionato √® un PE file consiste nel verificare che l'MZ signature sia 0x5a4d e che la signature sia 4550 
is_PEfile = mzsignature == 0x5a4d and pesignature == 0x4550
if not is_PEfile:
    printfailure("Il file target non √® un PE valido -> NON E' POSSIBILE EFFETUARE L'INIEZIONE\n")
    sys.exit(0)
else:
    printsuccess("Verifica PE File avvenuta con successo -> OK")
    
    #informazioni estratte dall' _IMAGE_FILE_HEADER:
    # per  leggere il numero di sezioni si parte dall'offset dell'_IMAGE_NT_HEADERS, e sommare 4 byte occupati dalla signature + 2 occupati da Machine, quindi PE_HEADER_offset+0x06    
    numberOfSections=readWORD(PE_HEADER_offset+0x06) #numero di sezioni presenti nel PE file
    #SizeOfOptionalHeader si trova in _IMAGE_FILE_HEADER al 20esimo byte dopo PE_HEADER_offset  
    sizeOfOptionalHeader=readWORD(PE_HEADER_offset+0x14) #SizeOfOptionalHeader il cui offset √® il 20esimo byte a partire dall'PE_HEADER_offset e si trova in _IMAGE_FILE_HEADER
    
    #informazioni estratte dall _IMAGE_OPTIONAL_HEADER:
    #L'imagebase √® l'indirizzo a cui caricare l'immagine in memoria. Nel caso delle DLL il valore di default √® 0x10000000, mentre nel caso degli EXE 0x00400000.‚Äã
    #0x34 esadecimale corrisponde a 52 in binario, quindi sommando 52 byte al PE_HEADER_offset ottengo l'imagebase che si trova in _IMAGE_OPTIONAL_HEADER 
    imagebase=readDWORD(PE_HEADER_offset+0x34)  #l'image base address del binario
    sectionAlignment=readDWORD(PE_HEADER_offset+0x38) #il valore con cui le sezioni sono allineate in memoria (RAM)
    #0x3c esadecimale corrisponde a 60 in decimale
    fileAlignment=readDWORD(PE_HEADER_offset+0x3c)    #il valore con cui le sezioni sono allineate su disco (PEFILE)
    

    printsuccess("Il file √® stato analizzato con successo: ")
    print("PE Header Offset:",hex(PE_HEADER_offset),"\nImage Base:",hex(imagebase),"\nSection Alignment:",sectionAlignment,"(",hex(sectionAlignment),")")
    print("File Alignment:",fileAlignment,"(",hex(fileAlignment),")","\nNumero di sezioni:",numberOfSections)
    
    #0x18 corrisponde a 24 in decimale (4 LA SIGNATURE E 20 LA DIMENSIONE DEL IMAGE_FILE_HEADER), quindi partendo da PE_HEADER_offset e sommando 24 byte siamo all'inzio #di _IMAGE_OPTIONAL_HEADER 
    #poi sommiamo la dimensione di _IMAGE_OPTIONAL_HEADER e siamo al primo IMAGE_SECTION_HEADER. 
    #PE_HEADER_offset+0x18+sizeOfOptionalHeader = offset IMAGE_SECTION_HEADER (Section Table)
    #cos'√® la Section Table? E' un array di strutture IMAGE_SECTION_HEADER (una per ogni sezione, vedremo dopo la struttura) e il numero di elementi nella #struttura √® determinato dal NumberOfSections nella struttura File Header
    #sapendo che ogni Header di Sezione (.text, data, bss, rdata ecc.) ha un numero di byte pari a 28 hex (40byte, in decimale), sommiamo (numberOfSections-1)*0x28 ed otteniamo #l'offset dell'IMAGE_SECTION_HEADER dell' ultima sezione   
    lastSectionOffset=PE_HEADER_offset+0x18+sizeOfOptionalHeader+(numberOfSections-1)*0x28 #l'offset dell'ultima sezione nel file
    #leggo il primo campo di IMAGE_SECTION_HEADER --> BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];
    lastSectionName=readNString(lastSectionOffset,8)
    
    printsuccess("Offset dell'ultima sezione √® stato calcolato con successo")
    print("offset ultima sezione:",hex(lastSectionOffset),"\n Nome dell'ultima sezione:",lastSectionName)
    
    #N.B: L'indirizzo virtuale √® l'indirizzo originale nella memoria mentre l'indirizzo virtuale relativo (RVA) √® l'indirizzo relativo rispetto all'ImageBase. #ImageBase indica l'indirizzo di base in cui il file eseguibile viene caricato per la prima volta nella memoria.
    #lastSectionVirtualAddress indica il RVA dell'ultima sezione, quindi sarebbe dove si trova l'ultima sezione a partire dall'imagebase nell'exe e NON NELLA MEMORIA
    #lastSectionVirtualAddress indica da quale RVA il loader deve mappare la sezione
    #PER SAPERE L'INDIRIZZO DI MEMORIA IN CUI LA SEZIONE SARA' CARICATA DEVO SOMMARE L'ImageBase al lastSectionVirtualAddress
    #alcuni campi estratti dall'ultima sezione
    lastSectionVirtualSize,lastSectionVirtualAddress,lastSectionRawSize,lastSectionRawAddress=readDWORDs(lastSectionOffset+0x08,4) 
    
        
    print("ULTIMA SEZIONE NEL FILE TARGET: ")
    print(lastSectionVirtualSize, " ", hex(lastSectionVirtualSize))
    print("VIRTUAL ADDRESS: ", lastSectionVirtualAddress, " ", hex(lastSectionVirtualAddress))
    print("RAW SIZE E RAW ADDRESS: ")
    print(lastSectionRawSize, " ", hex(lastSectionRawSize))
    print(lastSectionRawAddress, " ", hex(lastSectionRawAddress))
    print()
    
    #calcolo la dimensione in byte del file indicato come payload
    payload_size=os.stat(args.payload).st_size 
    
    printinfo("Il file payload ha dimensione: "+str(payload_size/1024)+" KB")
   
  
    #*** CREO UNA SEZIONE CHE SIA IN GRADO DI CONTENERE TUTTO IL FILE PAYLOAD
    
    #SectionAligment, allineamento sezioni in memoria.
    #FileAligment, allineamento sezioni sul disco.
     
    #payload_virtualAddress contiene il RVA (relative virtaul address) della nuova ultima sezione.
    #payload_virtualAddress viene calcolato prendendo la dimensione dell'ultima sezione (dividendola per l'allineamento in meoria ed approssimando per eccesso) e #sommando tale valore al virtual address dell'ultima sezione 
    payload_virtualAddress=lastSectionVirtualAddress+math.ceil(lastSectionVirtualSize/sectionAlignment)*sectionAlignment #math.ceil approssima per ecceso all'intero pi√π vicino
    #payload_rawAddress √® ottenuto allo stesso modo di payload_virtualAddress    
    payload_rawAddress=lastSectionRawAddress+math.ceil(lastSectionRawSize/fileAlignment)*fileAlignment
    #payload_rawSize indica il valore della dimensione della sezione RawData su disco
    payload_rawSize=math.ceil(payload_size/fileAlignment)*fileAlignment
    #payload_virtualSize indica il valore della dimensione della sezione in memoria
    payload_virtualSize=math.ceil(payload_size/sectionAlignment)*sectionAlignment
    # CODE | EXECUTE | READ | WRITE
    payload_characterstics=0xe0000060 
    
    
    printsuccess("Campi del nuovo header calcolati con successo")
    print("Nome nuova sezione:",args.name)
    print("Payload Virtual address:",hex(payload_virtualAddress),"\nVirtual Size:",hex(payload_virtualSize),"\nRaw Size:",hex(payload_rawSize))
    print("Payload Raw Address:",hex(payload_rawAddress),"\nCharacterstics:",hex(payload_characterstics))
    
        
    #preparo l'header del payload in relazione al file target. In pratica i campi del payload saranno calcolati considerando il payload come la nuova ultima sezione del target. Ovviamente il file exe payload gi√† aveva il suo header con i propri campi, ma divenendo parte del file target devono essere ricalcolati a partire dagli indirizzi del target
    #struct.pack Restituisce un oggetto bytes contenente i valori v1, v2, ‚Ä¶ impacchettati secondo il format string passato come primo argomento <LLLLLLLL. Gli #argomenti devono corrispondere esattamente ai valori richiesti dal formato.    
    #le L stanno per LONG 4byte pari a DWORD. struct.pack realizzo una struttura C fatta da 8 elementi di tipo LONG (4 byte come DWORD) In pratica mi sto costruendo _IMAGE_SECTION_HEADER:
    sectionheader = bytearray(args.name.encode("utf-8")+b"\x00"*(8-len(args.name)))+struct.pack("<LLLLLLLL",payload_virtualSize,payload_virtualAddress,payload_rawSize,payload_rawAddress,0,0,0,payload_characterstics)
    print("stampo section header:")
    print(sectionheader)
    print("")
    newsize=payload_virtualAddress+payload_virtualSize
    print(payload_virtualAddress)
    print(payload_virtualSize)
    print(newsize)
    
    numberOfSections+=1
    
    #leggo il file payload e lo salvo nella variabile payloadData
    with open(args.payload,"rb") as payload:
        payloadData=payload.read()
        #print(payloadData)
   
    printinfo("The values to be written are")
    print("Section Header:"," ".join([str(hex(x))[2:] for x in sectionheader]),"\nSection Header Length:",len(sectionheader),"( "+str(hex(len(sectionheader)))+" )","\nNew file size:",newsize,"\nNo of sections(updated):",numberOfSections)
    
    #aggiorno la dimensione del file
    writeDWORD(PE_HEADER_offset+0x50,newsize)
    #aggiorno la dimensione il numero di sezioni
    writeDWORD(PE_HEADER_offset+0x06,numberOfSections)
    #subito dopo l'ultima sezione del file target crea l'header del payload
    #creo l' IMAGE_SECTION_HEADER della nuova ultima sezione subito dopo l' IMAGE_SECTION_HEADER della vecchia ultima sezione.
    #tutti gli IMAGE_SECTION_HEADER sono consecutivo ed ogni struttura occupa 40 byte (0x28 in hex)
    writeDATA(lastSectionOffset+0x28,sectionheader)
    #print(targetData)
    
    #completa payloadData con una serie di byte a 0 (0x00) per allineare la sezione
    payloadData=payloadData+b"\x00"*(payload_rawSize-len(payloadData)) 
    
    #print(payloadData)
    #INSERISCE IL PAYLOAD ALL'INTERNO DELL'ULTIMA SEZIONE DEL FILE TARGET (targetData)
    targetData=targetData+payloadData
    
    if not args.replace: 
    														#".".join()... -> "." Ë un separatore usato per unire le varie stringhe nell'operazione di join, quindi le varie stringhe saranno unite ma separate da .
        newname=".".join(args.target.split(".")[:-1])+"_mod.exe" #divido il path target in array di stringhe, ogni stringa per ogni . trovato nel percorso, eliminando l'ultima stringa dopo l'ultimo punto (quindi exe); riunisco le stringhe separandole con il . (in pratica rimetto il punto dove stava tranne per l'ultimo) ed aggiungo la stringa _mod.exe modificando il nome del nuovo file
    else:
        newname=args.target
    print(newname)    
    with open(newname,"wb") as outfile:
        outfile.write(targetData) #viene creato un file exe risultante in cui viene scritto tutto il contenuto targetData
    
    printsuccess("iniezione del payload terminata con successo")
    
    